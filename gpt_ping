#!/bin/python
import requests
import json
import sys
import argparse
import os
import subprocess
import parser
import backends

# Get the path to the directory were this file is located
script_dir = os.path.dirname(os.path.realpath(__file__))

# Number of times a request will be attempted to
max_number_of_tries = 3

# gets the api key
api_key = ''
with open(f"{script_dir}/open_ai.secrets") as secret:
    api_key = secret.readline().strip('\n')

# The API endpoint for the model you want to use
endpoint = "https://api.openai.com/v1/chat/completions"

headers = {
    "Content-Type": "application/json",
    "Authorization": f"Bearer {api_key}"
}


def send_request(data, headers, backend):
    '''Attempts to send the request to the backend'''
    for _ in range(max_number_of_tries):
        response = requests.post(endpoint,
                                 headers=headers,
                                 data=json.dumps(data),
                                 timeout=args.t)
        match response.status_code:
            case 200:
                message = response.json()['choices'][-1]['message']['content']
                return message
            case _:
                print(f"an oupise of type {response.status_code} happend, retrying...")

    sys.exit(1)


# Argument parsing ----------------------------------------------------------

# loading the preset information
presets = {}
with open(f'{script_dir}/gpt_presets.json') as read:
    presets = json.load(read)
preset_list = list(presets)

# Parses the command line arguments
arg_parser = argparse.ArgumentParser()

arg_parser.add_argument(
    'preset',
    help=f'Preset of the assistance. Can be one of: {preset_list}',
    default='default',
    nargs='?')
arg_parser.add_argument(
    '-p',
    help='If used, the program will not run in interactive mode, only the',
    type=str)
arg_parser.add_argument('-T', '--temperature', type=float, default=1)
arg_parser.add_argument('-b', '--backend', type=str, default="gpt3.5")
arg_parser.add_argument('-t',
                    help='response timeout (seconds)',
                    type=int,
                    default=10)
arg_parser.add_argument('-l',
                    '--response_length',
                    help='Maximum number of tokens',
                    type=int,
                    default=200)
arg_parser.add_argument('-m',
                    '--message',
                    help='override preset and send message',
                    type=str)

args = arg_parser.parse_args()

# Main discussion loop --------------------------------------------------------

# reads the preset, some of them require extra data, commands will be ran to
# acquire it
discussion = eval(
    args.message) if args.message else presets[args.preset]['prompt']

if 'data' in presets[args.preset]:
    for data_name, data_command in presets[args.preset]['data'].items():
        result = subprocess.run([data_command],
                                shell=True,
                                capture_output=True).stdout.decode()
        discussion[0]["content"] = discussion[0]["content"].replace(
            '{' + str(data_name) + '}', result)

# Actual loop
while True:
    if (content_user := input('> '))[0] == "/":
        print('command was detected!')
        parser.command(content_user)
        continue

    message_user = {"role": "user", "content": content_user}

    discussion.append(message_user)

    # The data to send to the API
    data = {
        "model": "gpt-3.5-turbo",
        "messages": discussion,
        "max_tokens": args.response_length,
        "temperature": args.temperature,
    }

    content_assistant = send_request(data, headers, args.backend)

    message = {"role": "assistant", "content": content_assistant}
    discussion.append(message)

    with open(f'{script_dir}/log/discussion.txt', 'w') as file:
        file.write(str(discussion))

    with open('temp.txt', 'w') as file:
        file.write(content_assistant)

    subprocess.run(
        ["glow temp.txt -s '/home/amda/.config/glow/gpt_style.json'"],
        shell=True)

    parser.code(content_assistant)
